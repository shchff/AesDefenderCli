# AesDefenderCli

Учебный вузовский проект для исследования поведения AES в режиме электронной кодовой книги (ECB) и демонстрации его уязвимости.

Программа моделирует «шифровальщик» и показывает, как наличие словаря в зашифрованном файле делает возможным восстановление данных **без знания ключа**, если используется AES-ECB.

---

## Кратко о AES и режиме ECB

**AES (Advanced Encryption Standard)** — симметричный блочный шифр, работающий с блоками фиксированного размера (128 бит = 16 байт). AES сам по себе — это только блочный примитив; для шифрования произвольных данных применяют режимы работы (modes) — ECB, CBC, CTR, GCM и др.

**ECB (Electronic Codebook)** — самый простой режим: каждый блок plaintext шифруется независимо тем же ключом:

```
C_i = AES_K(P_i)
```

**Почему это плохо:** одинаковые plaintext-блоки дают одинаковые ciphertext-блоки. При повторяющейся структуре (например, пиксели изображения или повторяющиеся байты) структура данных «просвечивает» через шифр. Это делает ECB **ненадёжным для конфиденциальных данных**.

**Примеры проблем ECB:**

* визуально узнаваемые изображения после шифрования (контуры остаются),
* возможность проведения атак со словарём, если формат данных предсказуем (как в этом проекте).

**Поэтому в практических системах** для конфиденциальности используют режимы с IV/nonce/аутентификацией: CBC (с случайным IV), GCM, ChaCha20-Poly1305 и другие.

---

## Идея проекта

1. `prepare` — расширяет исходный файл так, чтобы каждый байт стал отдельным AES-блоком: `[byte, 0x00, ..., 0x00]` (16 байт); и помещает **в начало** файла словарь (`dictionary`) — 256 таких блоков для значений `0..255`.
2. `encode` — шифрует подготовленный файл AES-128 в режиме **ECB/NoPadding** случайным ключом.
3. `translate` — читает первые 256 зашифрованных блоков (зашифрованный словарь) и строит `mapping` из `hex(cipherblock) -> byte_value`.
4. `decode` — по `mapping` восстанавливает каждый блок в plaintext (подставляет соответствующий первый байт блока), затем удаляет словарь и "сжимает" расширённые блоки — получаем исходный файл без знания ключа.

Это демонстрация: **наличие словаря в зашифрованном файле и использование ECB позволяют восстановление данных**.

---

## Требования

* Java 11+
* Maven 3.x

---

## Сборка

```bash
mvn clean package
```

В результате соберётся JAR: `target/AesDefenderCli-1.0-SNAPSHOT.jar` (при условии корректного `pom.xml` с указанием `Main-Class`).

---

## Использование

Общий формат:

```bash
java -jar target/AesDefenderCli-1.0-SNAPSHOT.jar <command> [options]
```

### prepare

Подготовка файла (создание словаря + расширение данных):

```bash
java -jar target/AesDefenderCli-1.0-SNAPSHOT.jar prepare -i bear.jpg -o prepared.bin
```

### encode

Шифрование (AES-128 ECB, NoPadding). Можно сохранить ключ в файл `-k`.

```bash
java -jar target/AesDefenderCli-1.0-SNAPSHOT.jar encode -i prepared.bin -o encrypted.bin -k key.bin
```

### translate

Построение таблицы соответствия по зашифрованному словарю (первые 256 блоков):

```bash
java -jar target/AesDefenderCli-1.0-SNAPSHOT.jar translate -i encrypted.bin -m mapping.txt
```

Формат `mapping.txt`:

```
<hex_of_cipher_block>;<decimal_byte_value>
```

Пример строки:

```
5f8d3a12ab...c7;72
```

### decode

Восстановление файла по `mapping`:

```bash
java -jar target/AesDefenderCli-1.0-SNAPSHOT.jar decode -i encrypted.bin -m mapping.txt -o recovered.jpg
```

---

## Пример (пошагово)

Исходник: `bear.jpg` с изображением медведя.

1. `prepare` → `prepared.bin` = `[dictionary(4096B)] + [expanded HELLO (5 * 16B)]`
2. `encode` → `encrypted.bin`
3. `translate` → `mapping.txt` (256 записей `hex;value`)
4. `decode` → `recovered.jpg` = Восстановленное изображение

---

## Почему словарь из 256 блоков достаточен

Мы расширяем каждый байт в файл до отдельного блока `[b, 0x00...0]`. Таких возможных блоков ровно 256 (значения байта 0..255). Соответственно словарь, содержащий все 256 вариантов, покрывает все возможные одиночные-байтовые блоки — это гарантирует, что для любого блока данных найдётся соответствие в словаре.

---

## Проблемы и замечания

* Текущая реализация читает файлы целиком в память. Для больших файлов стоит переделать на потоковую обработку по блокам.
* В реальной задаче никогда не используйте ECB для конфиденциальных данных. Применяйте CBC/GCM/ChaCha20 и обязательно аутентификацию.
---

## Этика

Этот проект — образовательный. Используй знания для повышения безопасности и понимания криптографии, а не для вреда.
